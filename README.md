**IMPORTANT: if you have found this repo, please note that it is a work in very early progress, and is undergoing testing. Do not use in production! If you like the idea and are interested in contributing, let me know.**

---

# jamf-versioner

`jamf-versioner` is a tool to help better handle scoping of policies in Jamf
Pro. With the help of
[munkilib](https://github.com/munki/munki/tree/master/code/client/munkilib),
it compares the locally installed version of an application of other piece of
software with the versions considered "current" and "untested" in Jamf Pro.

Importantly, a computer is only in scope if the installed version is **less than** either the current or untested version. This improves on the built-in tools of Jamf Pro which can only determine if a version matches or does not match.

The "current" and "untested" versions are passed to the client through an
Extension Attribute for each policy. This means you do need an extension attribute for every policy. I have tried to design the extension attribute to run as quick as possible. There are no API calls to look for the current/untested versions from the server, as these are stored locally on each device.

To ensure the Extension Attribute can be uploaded to the Jamf Pro Server via
automation (e.g. [AutoPkg](https://github.com/autopkg/autopkg)), the version and configuration information for each
policy is written to a file on each client each time the extension attribute is
run.

## Requirements

The Munki Core Tools must be installed on each client. This is obtainable via AutoPkg with the `MunkiToolsCore.pkg` or `MunkiToolsCore.jss` recipes in [grahampugh/recipes](https://github.com/grahampugh/recipes).

The files `__init__.py`, `jamf_versioner.py` and `write_version_to_json_file.py` must be present in `/usr/local/munki/versioner`.

The easiest way to install `jamf-versioner` on clients is to generate a package by typing `make` from this folder (requires [MunkiPkg](https://www.munki.org/munki-pkg/) to be installed in `/usr/local/bin`), which can then be distributed to clients.

The package will also eventually be available in GitHub (TODO) and via AutoPkg recipe (TODO).

The templates `Versioner-ExtensionAttribute.xml` and `Versioner-SmartGroupTemplate.xml` must be present in your AutoPkg `RecipeOverrides` folder, and must be referred to in your `.jss` recipe. See the `Example Recipe.jss.recipe` in the `example_templates` folder.

## Notes & Config

The Extension Attribute is uploaded by AutoPkg, including the following
information:

| key | description | default |
|-----|-------------|---------|
| `policy_name` | The name of the policy. | None |
| `version_check_type` | This specifies which type of policy this is: either  `app`, `pkg` or `script`. `app` can be used for any application- or plugin-bundle which has a `plist` containing version information. |  `app` |
| `app_path`| For `app`-type checks, this specifies the path to the application, from which it will determine the installed version by interrogating the `Info.plist` file. For normal apps and some plugins, it automatically adds `Contents/Info.plist` to the path. If the path does not end in `.app` or `.plugin`, but the version is still obtainable from a `plist` file, you can specify the full path to the `plist`. | `Applications/%NAME%.app` |
| `app_key` | The key in the `Info.plist` or other `plist` file which is to be used to determine the version. | `CFBundleShortVersionString` |
| `pkgid` | For `pkg`-type checks, this specifies the package receipt identifier, for example `com.skype.skype`. The package receipt version must match the version generated by your automation (e.g. AutoPkg). Importantly, if using this method, the software must be uninstalled using a script/policy which forgets the package receipt, otherwise the script will still think the software is installed. That means, of course, if somebody manually installs the software using some other means, remediation will be required. | None |
| `jamf_test_version` | The version number generated by AutoPkg, which is injected into the Extension Attribute during the AutoPkg JSSImporter process. | `%version%` |
| `jamf_current_version` | When staging a policy to production, this value needs to be written into the Extension Attribute. One way to achieve this is using the `write_current_version_to_ea.py` script in the `scripts` folder of this repo. Note that this is overwritten by AutoPkg as there is no process in JSSImporter to selectively edit values in uploaded elements. | 0.0.0 |
| `script_version` | More complex version determination can be included in the extension attribute of a policy as required. Please note that the extension attributes are written in Python, so you'll have to be comfortable with Python to write them. I may include some common ones in this repository in future. | None |

Each of these values must be present in the Extension Attribute of each policy, regardless of whether used.

Each of these values is overrideable in a `.jss` recipe's `Inputs` section, with the following input keys:

| key | Input in JSS Recipe | Required? |
|-----|---------------------|-----------|
| `policy_name` | `%NAME%` | Yes |
| `version_check_type` | `%VERSIONER_TYPE%` | No |
| `app_path` | `%VERSIONER_APP_PATH%` | No |
| `app_key` | `%VERSIONER_APP_KEY%` | No |

When the extension attribute is first run on a client, it will generate an entry in the file `/Library/Application Support/JAMF/software_versions.json` (or generate the file if it is not yet there). the `jamf_test_version` will be written to the file, and then the version check is made and reported back to the Jamf Pro Server.

Since there is not yet a `jamf_current_version` reported to the client, any installed version will report itself higher than the current version. This will show in the EA result as `+current` That's OK, because we don't want to put the client in scope.

If the client is in the Testing computer group, it will do a version check against the `jamf_test_version`. If the installed version is less than the `jamf_test_version`, (or if there is no installed version at all), the version will report as `-untested` and the computer is therefore in scope.

Once we stage a policy or manually inject the `jamf_current_version` into the EA, and the client does a `recon`, a true comparison with the `jamf_current_version` will take place. Your production policies should therefore be scoped based (at least) on the following criterion (obviously you can add more criteria):

```xml
<criterion>
    <name>%NAME% Version</name>
    <and_or>and</and_or>
    <search_type>like</search_type>
    <value>-current</value>
</criterion>
```

The following scenarios are realistically possible (ignoring other criteria in the smart groups):

| EA value | Scoped to untested policy | Scoped to production policy |
|----------|--------------------------|-----------------------------|
| -current,-untested | Yes | Yes |
| =current,-untested | Yes | No  |
| +current,-untested | Yes | No  |
| =current,=untested | No  | No  |
| +current,=untested | No  | No  |
| +current,+untested | No  | No  |
